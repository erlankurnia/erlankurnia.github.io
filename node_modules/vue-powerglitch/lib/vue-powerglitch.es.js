var b = Object.defineProperty, w = Object.defineProperties;
var M = Object.getOwnPropertyDescriptors;
var g = Object.getOwnPropertySymbols;
var A = Object.prototype.hasOwnProperty, H = Object.prototype.propertyIsEnumerable;
var y = (t, n, e) => n in t ? b(t, n, { enumerable: !0, configurable: !0, writable: !0, value: e }) : t[n] = e, p = (t, n) => {
  for (var e in n || (n = {}))
    A.call(n, e) && y(t, e, n[e]);
  if (g)
    for (var e of g(n))
      H.call(n, e) && y(t, e, n[e]);
  return t;
}, v = (t, n) => w(t, M(n));
import { defineComponent as L, ref as _, onMounted as x, openBlock as R, createElementBlock as j, normalizeStyle as P, createElementVNode as E, renderSlot as T } from "vue";
var f = {};
Object.defineProperty(f, "__esModule", { value: !0 });
var m = f.PowerGlitch = void 0;
const G = (t = "always") => ({
  playMode: t,
  createContainers: !0,
  hideOverflow: !1,
  timing: t === "always" ? { duration: 2 * 1e3, iterations: 1 / 0 } : { duration: 250, iterations: 1 },
  glitchTimeSpan: t === "always" ? { start: 0.5, end: 0.7 } : { start: 0, end: 1 },
  shake: {
    velocity: 15,
    amplitudeX: 0.2,
    amplitudeY: 0.2
  },
  slice: t === "click" ? {
    count: 15,
    velocity: 20,
    minHeight: 0.02,
    maxHeight: 0.15,
    hueRotate: !0
  } : {
    count: 6,
    velocity: 15,
    minHeight: 0.02,
    maxHeight: 0.15,
    hueRotate: !0
  }
}), $ = (t, n) => {
  if (!t.glitchTimeSpan)
    return 1;
  const e = t.glitchTimeSpan.start, i = t.glitchTimeSpan.end;
  if (n < e || n > i)
    return 0;
  const a = e + (i - e) / 2;
  return n < a ? (n - e) / (a - e) : (i - n) / (i - a);
}, d = (t, n) => (Math.random() - 0.5) * 2 * $(t, n), B = ({ minHeight: t, maxHeight: n, minWidth: e, maxWidth: i }) => {
  const a = Math.floor(Math.random() * ((n - t) * 100 + 1)) + t * 100, l = Math.floor(Math.random() * ((i - e) * 100 + 1)) + e * 100, r = Math.floor(Math.random() * (100 - a)), c = Math.floor(Math.random() * (100 - l)), h = `${c + l}% ${r}%`, o = `${c + l}% ${r + a}%`, s = `${c}% ${r + a}%`, u = `${c}% ${r}%`;
  return `polygon(${h},${o},${s},${u})`;
}, N = (t) => {
  const n = Math.floor(t.slice.velocity * t.timing.duration / 1e3) + 1, e = [];
  for (let i = 0; i < n; ++i) {
    if ($(t, i / n) === 0) {
      e.push({
        opacity: "0",
        transform: "",
        clipPath: "unset"
      });
      continue;
    }
    const a = d(t, i / n) * 30, l = {
      opacity: "1",
      transform: `translate3d(${a}%,0,0)`,
      clipPath: B({ minHeight: t.slice.minHeight, maxHeight: t.slice.maxHeight, minWidth: 1, maxWidth: 1 })
    };
    t.slice.hueRotate && (l.filter = `hue-rotate(${Math.floor(d(t, i / n) * 360)}deg)`), e.push(l);
  }
  return {
    steps: e,
    timing: Object.assign({ easing: `steps(${n},jump-start)` }, t.timing)
  };
}, S = (t) => {
  if (!t.shake)
    return {
      steps: [],
      timing: {}
    };
  const n = Math.floor(t.shake.velocity * t.timing.duration / 1e3) + 1, e = [];
  for (let i = 0; i < n; ++i) {
    const a = d(t, i / n) * t.shake.amplitudeX * 100, l = d(t, i / n) * t.shake.amplitudeY * 100;
    e.push({
      transform: `translate3d(${a}%,${l}%,0)`
    });
  }
  return {
    steps: e,
    timing: Object.assign({ easing: `steps(${n},jump-start)` }, t.timing)
  };
}, C = (t) => [
  S(t),
  ...Array.from({ length: t.slice.count }).map(() => N(t))
], k = (...t) => {
  const n = (e) => e && typeof e == "object";
  return t.reduce((e, i) => (Object.keys(i).forEach((a) => {
    const l = e[a], r = i[a];
    if (Array.isArray(l) && Array.isArray(r)) {
      e[a] = l.concat(...r);
      return;
    }
    if (n(l) && n(r)) {
      e[a] = k(l, r);
      return;
    }
    r !== void 0 && (e[a] = r);
  }), e), {});
}, V = (t, n) => {
  var e, i;
  if (!n.createContainers)
    return {
      container: t,
      layersContainer: t,
      glitched: t.firstElementChild
    };
  if (!t.dataset.glitched) {
    const r = document.createElement("div"), c = document.createElement("div");
    return getComputedStyle(t).getPropertyValue("display").match(/^inline/) && (c.style.display = "inline-block"), c.appendChild(r), (e = t.parentElement) === null || e === void 0 || e.insertBefore(c, t), r.prepend(t), {
      container: c,
      layersContainer: r,
      glitched: t
    };
  }
  const a = t.parentElement, l = (i = t.parentElement) === null || i === void 0 ? void 0 : i.parentElement;
  for (; a.children.length > 1; )
    a.removeChild(a.children[1]);
  return a.firstElementChild.getAnimations().forEach((r) => r.cancel()), {
    container: l,
    layersContainer: a,
    glitched: t
  };
}, X = (t, n, e) => {
  const { glitched: i, container: a, layersContainer: l } = V(t, e);
  l.style.display = "grid", e.hideOverflow && (a.style.overflow = "hidden"), e.html && (i.innerHTML = e.html), i.style.gridArea = "1/1/-1/-1";
  const r = i.cloneNode(!0);
  r.style.gridArea = "1/1/-1/-1", r.style.userSelect = "none", r.style.pointerEvents = "none", r.style.opacity = "0";
  for (let o = 0; o < n.length - 1; ++o) {
    const s = r.cloneNode(!0);
    l.appendChild(s);
  }
  const c = () => {
    n.forEach((o, s) => {
      l.children[s].animate(o.steps, o.timing);
    });
  }, h = () => {
    n.forEach((o, s) => {
      l.children[s].getAnimations().forEach((u) => {
        u.cancel();
      });
    });
  };
  switch (a.onmouseenter = null, a.onmouseleave = null, a.onclick = null, e.playMode) {
    case "always":
      c();
      break;
    case "hover":
      a.onmouseenter = c, a.onmouseleave = h;
      break;
    case "click":
      a.onclick = () => {
        h(), c();
      };
      break;
  }
  return t.dataset.glitched = "1", { container: a, startGlitch: c, stopGlitch: h };
}, q = (t = ".powerglitch", n = {}) => {
  const e = k(G(n.playMode), n);
  let i = [];
  typeof t == "string" ? i = Array.from(document.querySelectorAll(t)) : t instanceof NodeList ? i = Array.from(t) : Array.isArray(t) ? i = t : t instanceof HTMLElement && (i = [t]);
  const a = C(e), l = i.map((r) => X(r, a, e));
  return {
    containers: l.map((r) => r.container),
    startGlitch: () => l.forEach((r) => r.startGlitch()),
    stopGlitch: () => l.forEach((r) => r.stopGlitch())
  };
};
m = f.PowerGlitch = {
  glitch: q,
  generateLayers: C,
  getDefaultOptions: G
};
const D = /* @__PURE__ */ L({
  __name: "GlitchedElement",
  props: {
    options: {
      type: Object,
      required: !1,
      default: () => ({})
    },
    inline: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  setup(t, { expose: n }) {
    const e = t;
    let i = () => {
    }, a = () => {
    };
    const l = _(null);
    return x(() => {
      ({ startGlitch: i, stopGlitch: a } = m.glitch(l.value, v(p({}, e.options), { createContainers: !1 })));
    }), n({
      startGlitch: () => i(),
      stopGlitch: () => a()
    }), (r, c) => (R(), j("div", {
      style: P({ display: t.inline ? "inline-block" : "block" })
    }, [
      E("div", {
        ref_key: "glitched",
        ref: l
      }, [
        E("div", null, [
          T(r.$slots, "default")
        ])
      ], 512)
    ], 4));
  }
}), Y = {
  mounted: (t, n) => {
    m.glitch(t, n.value);
  }
}, I = {
  install: (t) => {
    t.component("GlitchedElement", D), t.directive("glitch", Y);
  }
};
export {
  D as GlitchedElement,
  I as PowerGlitchPlugin,
  I as default,
  Y as vGlitch
};
